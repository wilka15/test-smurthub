<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SmartHub AI ‚Äî Full</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root{
      --accent:#7a5bff; --accent2:#00a6ff; --bg1:#06020a; --panel: rgba(255,255,255,0.04);
      --glass: rgba(255,255,255,0.06); --text:#eaf6ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(135deg,#070014,#001233);font-family:"Orbitron",system-ui,Arial;color:var(--text);-webkit-font-smoothing:antialiased}
    /* layout */
    .app{width:94%;max-width:1200px;margin:24px auto;height:88vh;position:relative;display:flex;gap:20px}
    /* CHAT */
    .chat-wrap{flex:1;display:flex;flex-direction:column;gap:12px}
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:16px;padding:18px;border:1px solid rgba(122,91,255,0.12);
      box-shadow: 0 8px 40px rgba(15,10,30,0.6); height:100%; display:flex; flex-direction:column;
      backdrop-filter: blur(8px);
    }
    #chat{flex:1; overflow:auto; padding-right:8px;}
    .msg{display:flex;margin:10px 6px;opacity:1}
    .msg.user{justify-content:flex-end}
    .bubble{
      max-width:72%; padding:12px 14px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); color:var(--text);
      box-shadow: 0 6px 18px rgba(0,0,0,0.4);
    }
    .bubble.user{ background: linear-gradient(135deg, rgba(122,91,255,0.95), rgba(0,166,255,0.85)); color:#021; }
    .bubble.ai{ background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); color:var(--text); }
    /* input */
    .input-row{display:flex;gap:10px;align-items:center;margin-top:8px}
    .input-row input[type="text"], .input-row input[type="search"]{flex:1;padding:12px 14px;border-radius:10px;border:none;background:rgba(255,255,255,0.03);color:var(--text);outline:none}
    .btn{padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:700;background:linear-gradient(135deg,var(--accent),var(--accent2));color:#001}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text)}
    .btn.clear{background:rgba(255,255,255,0.04);color:var(--text)}
    /* small controls */
    .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
    .hidden{display:none}
    /* typing indicator */
    .typing-indicator { display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius:10px; background: rgba(255,255,255,0.02); }
    .typing-indicator .dot { width:8px; height:8px; background:#fff; border-radius:50%; opacity:0.6; transform: translateY(0); animation: bounce 1.2s infinite ease-in-out; box-shadow: 0 0 10px rgba(122,91,255,0.28); }
    .typing-indicator .dot:nth-child(1){ animation-delay: 0s; }
    .typing-indicator .dot:nth-child(2){ animation-delay: 0.12s; }
    .typing-indicator .dot:nth-child(3){ animation-delay: 0.24s; }
    @keyframes bounce { 0%{transform:translateY(0);opacity:0.35} 30%{transform:translateY(-6px);opacity:1} 60%{transform:translateY(0);opacity:0.35} 100%{transform:translateY(0);opacity:0.35} }
    /* slide animations for messages */
    @keyframes slideInRight { from{transform:translateX(40px);opacity:0} to{transform:translateX(0);opacity:1} }
    @keyframes slideInLeft { from{transform:translateX(-40px);opacity:0} to{transform:translateX(0);opacity:1} }
    .msg.user .bubble{animation: slideInRight .32s cubic-bezier(.22,.9,.24,1)}
    .msg.ai .bubble{animation: slideInLeft .32s cubic-bezier(.22,.9,.24,1)}
    /* slide-menu */
    .menu-toggle{position:fixed;right:20px;top:20px;z-index:60;padding:10px 12px;border-radius:10px;border:none;background:linear-gradient(135deg,var(--accent),var(--accent2));color:#001;cursor:pointer;box-shadow:0 8px 30px rgba(0,0,0,0.5)}
    .slide-menu{position:fixed;right:0;top:0;height:100vh;width:0;overflow:hidden;z-index:70;transition:width .36s cubic-bezier(.2,.9,.2,1);border-left:1px solid rgba(255,255,255,0.03)}
    .slide-menu.open{width:360px}
    .menu-inner{height:100%;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));backdrop-filter: blur(8px);padding:22px;display:flex;flex-direction:column;gap:14px}
    .menu-inner h3{margin:0;color:var(--accent)}
    .menu-card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,0.03)}
    .menu-row{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:8px 0}
    label.switch{display:inline-flex;align-items:center;gap:8px}
    .small-btn{padding:8px 10px;border-radius:8px;border:none;background:linear-gradient(135deg,var(--accent),var(--accent2));color:#001;cursor:pointer}
    .small{font-size:12px;opacity:0.8}
    /* responsive */
    @media (max-width:880px){ .slide-menu.open{width:100vw} .menu-inner{padding:14px} .app{margin:8px} }
  </style>
</head>
<body>
  <div class="neon-bg">
    <div class="neon n1"></div>
    <div class="neon n2"></div>
    <div class="neon n3"></div>
  </div>

  <div class="app">
    <div class="chat-wrap">
      <div class="panel">
        <div id="chat" aria-live="polite"></div>

        <div class="input-row" style="margin-top:12px">
          <input id="inputText" type="text" placeholder="–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..." aria-label="–°–æ–æ–±—â–µ–Ω–∏–µ" />
          <button id="sendBtn" class="btn">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
          <button id="clearBtn" class="btn clear">–û—á–∏—Å—Ç–∏—Ç—å</button>
        </div>

        <div class="controls">
          <input id="imagePrompt" type="search" placeholder="–ü—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è..." aria-label="–ü—Ä–æ–º–ø—Ç" />
          <button id="genImageBtn" class="btn ghost">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</button>
          <button id="uploadFileBtn" class="btn ghost">–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª</button>
          <input id="fileInput" type="file" class="hidden" />
          <button id="downloadBtn" class="btn ghost" style="margin-left:auto">–°–∫–∞—á–∞—Ç—å –¥–∏–∞–ª–æ–≥</button>
        </div>

        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <div class="small" style="margin-left:auto">–í–µ—Ä—Å–∏—è 1.0.8 ‚Äî Neon</div>
        </div>
      </div>
    </div>
  </div>

  <button class="menu-toggle" id="menuToggle">‚ò∞</button>

  <!-- slide menu (glass neon) -->
  <aside class="slide-menu" id="slideMenu" aria-hidden="true">
    <div class="menu-inner" role="dialog" aria-label="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
        <button id="menuClose" class="small-btn" style="background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--text)">‚úï</button>
      </div>

      <div class="menu-card">
        <div style="font-weight:700;margin-bottom:8px">–ì–æ–ª–æ—Å</div>
        <div class="menu-row">
          <div>–û–∑–≤—É—á–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤</div>
          <button id="ttsToggle" class="small-btn">–û—Ç–∫–ª—é—á–µ–Ω–æ üîà</button>
        </div>
        <div class="menu-row">
          <div>–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å TTS</div>
          <button id="stopTTS" class="small-btn">üõë</button>
        </div>
        <div class="menu-row">
          <div>–ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥</div>
          <button id="micToggle" class="small-btn">–í–∫–ª üé§</button>
        </div>
      </div>

      <div class="menu-card">
        <div style="font-weight:700;margin-bottom:8px">–§–æ—Ç–æ</div>
        <div class="menu-row">
          <div>–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ—Ç–æ</div>
          <button id="photoSendBtn" class="small-btn">üì∑ –í—ã–±—Ä–∞—Ç—å</button>
          <input id="photoFile" type="file" accept="image/*" style="display:none" />
        </div>
      </div>

      <div class="menu-card">
        <div style="font-weight:700;margin-bottom:8px">–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ</div>
        <div class="menu-row">
          <div>–ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ</div>
          <label class="switch"><input id="autosave" type="checkbox" /><span class="small">LocalStorage</span></label>
        </div>
        <div class="menu-row">
          <div>–û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é</div>
          <button id="clearStorage" class="small-btn">–û—á–∏—Å—Ç–∏—Ç—å</button>
        </div>
      </div>

      <div style="margin-top:auto" class="small">–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ: LocalStorage ¬∑ –°–µ—Ç–µ–≤–æ–π API —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏</div>
    </div>
  </aside>

<script>
/* Elements */
const menuToggle = document.getElementById('menuToggle');
const slideMenu = document.getElementById('slideMenu');
const menuClose = document.getElementById('menuClose');

const chatEl = document.getElementById('chat');
const inputText = document.getElementById('inputText');
const sendBtn = document.getElementById('sendBtn');
const clearBtn = document.getElementById('clearBtn');
const downloadBtn = document.getElementById('downloadBtn');

const imagePrompt = document.getElementById('imagePrompt');
const genImageBtn = document.getElementById('genImageBtn');
const uploadFileBtn = document.getElementById('uploadFileBtn');
const fileInput = document.getElementById('fileInput');

const ttsToggle = document.getElementById('ttsToggle');
const stopTTS = document.getElementById('stopTTS');
const micToggle = document.getElementById('micToggle');
const photoSendBtn = document.getElementById('photoSendBtn');
const photoFile = document.getElementById('photoFile');

const autosaveCheckbox = document.getElementById('autosave');
const clearStorageBtn = document.getElementById('clearStorage');

let ttsEnabled = false;
let currentUtterance = null;
let rec = null;
let micActive = false;

/* Menu open/close */
menuToggle.onclick = () => {
  slideMenu.classList.toggle('open');
  slideMenu.setAttribute('aria-hidden', !slideMenu.classList.contains('open'));
};
menuClose.onclick = () => {
  slideMenu.classList.remove('open');
  slideMenu.setAttribute('aria-hidden', 'true');
};

/* Storage key */
const STORAGE_KEY = 'neon_chat_history_v1';

/* Utilities: save/load chat */
function saveChatToStorage() {
  if (!autosaveCheckbox.checked) return;
  const rows = [...chatEl.querySelectorAll('.msg')].map(m => {
    const who = m.classList.contains('user') ? 'user' : 'ai';
    const text = m.querySelector('.bubble')?.textContent || '';
    return {who, text, t: Date.now()};
  });
  localStorage.setItem(STORAGE_KEY, JSON.stringify(rows));
}
function loadChatFromStorage() {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return;
  try {
    const arr = JSON.parse(raw);
    chatEl.innerHTML = '';
    arr.forEach(item => {
      appendMessage(item.text, item.who, false);
    });
    chatEl.scrollTop = chatEl.scrollHeight;
  } catch(e){ console.warn('load error', e); }
}
function clearStorageAndUI() {
  localStorage.removeItem(STORAGE_KEY);
  chatEl.innerHTML = '';
}

/* Create message bubble and append */
function appendMessage(text, role='ai', save=true, type='text', filename='') {
  const wrap = document.createElement('div');
  wrap.className = 'msg ' + role;
  const bubble = document.createElement('div');
  bubble.className = 'bubble ' + (role==='user' ? 'user' : 'ai');
  bubble.dataset.type = type;

  if (type === 'image') {
    const img = document.createElement('img');
    img.src = text;
    img.alt = filename || 'image';
    img.style.maxWidth = '420px';
    img.style.borderRadius = '8px';
    img.loading = 'lazy';
    img.style.cursor = 'pointer';
    img.addEventListener('click', () => window.open(img.src, '_blank'));
    bubble.appendChild(img);
    bubble.dataset.raw = text;
    bubble.dataset.filename = filename;
  } else if (type === 'file') {
    const a = document.createElement('a');
    a.href = text;
    a.download = filename || 'file';
    a.textContent = filename ? `–°–∫–∞—á–∞—Ç—å ${filename}` : '–°–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª';
    bubble.appendChild(a);
    bubble.dataset.raw = text;
    bubble.dataset.filename = filename;
  } else {
    bubble.textContent = text;
    bubble.dataset.raw = text;
  }

  wrap.appendChild(bubble);
  chatEl.appendChild(wrap);
  chatEl.scrollTop = chatEl.scrollHeight;
  if (save) saveChatToStorage();
  return wrap;
}

/* Typing bubble (3 dots) */
function createTyping() {
  const wrap = document.createElement('div');
  wrap.className = 'msg ai';
  wrap.id = 'typingBubble';
  wrap.innerHTML = '<div class="bubble ai"><div class="typing-indicator"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div></div>';
  return wrap;
}
function showTyping() { removeTyping(); chatEl.appendChild(createTyping()); chatEl.scrollTop = chatEl.scrollHeight; }
function removeTyping() { const t = document.getElementById('typingBubble'); if (t) t.remove(); }

/* TTS helpers */
function speakText(text) {
  if (!('speechSynthesis' in window)) return;
  if (currentUtterance) speechSynthesis.cancel();
  const toSpeak = text.length > 300 ? text.slice(0,300) + '...' : text;
  const ut = new SpeechSynthesisUtterance(toSpeak);
  ut.lang = 'ru-RU';
  ut.onend = () => { currentUtterance = null; };
  currentUtterance = ut;
  speechSynthesis.speak(ut);
}
stopTTS.onclick = () => { if ('speechSynthesis' in window) speechSynthesis.cancel(); currentUtterance=null; };

/* Mic (SpeechRecognition) */
function initRecognitionIfNeeded() {
  if (rec) return;
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) return;
  rec = new SR();
  rec.lang = 'ru-RU';
  rec.interimResults = false;
  rec.maxAlternatives = 1;
  rec.onresult = (e) => { const txt = e.results[0][0].transcript; inputText.value = txt; };
  rec.onerror = (e) => { console.warn('rec error', e); };
  rec.onend = () => { if (micActive) rec.start(); };
}
micToggle.onclick = () => { const SR = window.SpeechRecognition || window.webkitSpeechRecognition; if (!SR) { alert('–ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤ –≤–∞—à–µ–º –±—Ä–∞—É–∑–µ—Ä–µ'); return; } initRecognitionIfNeeded(); micActive = !micActive; micToggle.textContent = micActive ? '–í—ã–∫–ª—é—á–∏—Ç—å üé§' : '–í–∫–ª üé§'; if (micActive) rec.start(); else rec.stop(); };

/* API endpoint (proxy) */
const API_URL = 'https://openai-proxy-ucgy.onrender.com';

/* Helper: safe fetch with timeout */
function fetchWithTimeout(url, options={}, timeout=60000) {
  return Promise.race([
    fetch(url, options),
    new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), timeout))
  ]);
}

/* Send text message and handle mixed content responses (text/image/url/file) */
let isSending = false;
async function sendMessage(textOverride) {
  if (isSending) return;
  const text = textOverride || inputText.value.trim();
  if (!text) return;
  appendMessage(text, 'user', true);
  inputText.value = '';
  showTyping();
  isSending = true;
  try {
    const body = JSON.stringify({ model: 'gpt-4o-mini', input: text });
    const res = await fetchWithTimeout(API_URL, { method: 'POST', headers: {'Content-Type':'application/json'}, body }, 60000);
    const data = await res.json();
    removeTyping();
    const contents = data.output?.[0]?.content || [];
    if (Array.isArray(contents) && contents.length) {
      for (const item of contents) {
        await handleAIItem(item);
      }
    } else {
      const answer = data.output?.[0]?.content?.[0]?.text || data.choices?.[0]?.message?.content || '–û—à–∏–±–∫–∞: –ø—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç';
      appendMessage(answer, 'ai', true);
      if (ttsEnabled) speakText(answer);
    }
  } catch (err) {
    removeTyping();
    appendMessage('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ ‚Äî –ø—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ', 'ai', true);
    console.error(err);
  } finally { isSending = false; }
}

/* Handle a single content item from AI */
async function handleAIItem(item) {
  try {
    if (!item) return;
    const type = (item.type || '').toLowerCase();
    // text
    if (type === 'text' || type === 'output_text' || item.text) {
      const txt = item.text || item.output_text || '';
      if (txt) appendMessage(txt, 'ai', true);
      return;
    }
    // image URL (user selected option 2)
    if (type.includes('image') && item.url) {
      appendMessage(item.url, 'ai', true, 'image', item.filename || 'image');
      return;
    }
    // image base64
    const imgB64 = item.image_base64 || item.base64 || item.b64;
    if (imgB64) {
      const mime = item.mime || 'image/png';
      const blobUrl = base64ToBlobUrl(imgB64, mime);
      appendMessage(blobUrl, 'ai', true, 'image', item.filename || `image.${mime.split('/')[1]||'png'}`);
      return;
    }
    // file as url
    if (item.url && !type.includes('image')) {
      appendMessage(item.url, 'ai', true, 'file', item.filename || item.url.split('/').pop());
      return;
    }
    // file base64
    const fileB64 = item.file_base64 || item.file_b64;
    if (fileB64) {
      const mime = item.mime || 'application/octet-stream';
      const blobUrl = base64ToBlobUrl(fileB64, mime);
      appendMessage(blobUrl, 'ai', true, 'file', item.filename || `file.${mime.split('/')[1]||'bin'}`);
      return;
    }
    // fallback
    appendMessage(JSON.stringify(item), 'ai', true);
  } catch (e) { console.error('handleAIItem error', e); }
}

/* Convert base64 to blob URL */
function base64ToBlobUrl(b64, mime) {
  try {
    const byteChars = atob(b64);
    const byteNumbers = new Array(byteChars.length);
    for (let i = 0; i < byteChars.length; i++) byteNumbers[i] = byteChars.charCodeAt(i);
    const byteArray = new Uint8Array(byteNumbers);
    const blob = new Blob([byteArray], { type: mime });
    return URL.createObjectURL(blob);
  } catch (e) { console.error('base64ToBlobUrl failed', e); return ''; }
}

/* Photo upload (user -> API analysis) */
photoSendBtn.onclick = () => photoFile.click();
photoFile.onchange = async function() {
  const file = this.files[0];
  if (!file) return;
  appendMessage('üì∑ –§–æ—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ', 'user', true);
  showTyping();
  const reader = new FileReader();
  reader.onload = async () => {
    const base64 = String(reader.result).split(',')[1];
    try {
      const body = JSON.stringify({ model: 'gpt-4o-mini', input: [{ type: 'input_image', image_base64: base64, filename: file.name, mime: file.type, instruction: '–û–ø–∏—à–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–∞ —Ä—É—Å—Å–∫–æ–º' }] });
      const res = await fetchWithTimeout(API_URL, { method: 'POST', headers: {'Content-Type':'application/json'}, body }, 60000);
      const data = await res.json();
      removeTyping();
      const contents = data.output?.[0]?.content || [];
      if (Array.isArray(contents) && contents.length) { for (const item of contents) await handleAIItem(item); }
      else { const ans = data.output?.[0]?.content?.[0]?.text || '–û—à–∏–±–∫–∞: –Ω–µ—Ç –æ—Ç–≤–µ—Ç–∞'; appendMessage(ans, 'ai', true); if (ttsEnabled) speakText(ans); }
    } catch (e) { removeTyping(); appendMessage('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–æ—Ç–æ', 'ai', true); console.error(e); }
  };
  reader.readAsDataURL(file);
};

/* File upload (user -> API) */
uploadFileBtn.onclick = () => fileInput.click();
fileInput.onchange = async function() {
  const file = this.files[0];
  if (!file) return;
  appendMessage(`üìÅ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω —Ñ–∞–π–ª: ${file.name}`, 'user', true);
  showTyping();
  const reader = new FileReader();
  reader.onload = async () => {
    const base64 = String(reader.result).split(',')[1];
    try {
      const body = JSON.stringify({ model: 'gpt-4o-mini', input: [{ type: 'input_file', file_base64: base64, filename: file.name, mime: file.type, instruction: '–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Ñ–∞–π–ª –∏ –¥–∞–π –∫–æ—Ä–æ—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ' }] });
      const res = await fetchWithTimeout(API_URL, { method: 'POST', headers: {'Content-Type':'application/json'}, body }, 120000);
      const data = await res.json();
      removeTyping();
      const contents = data.output?.[0]?.content || [];
      if (Array.isArray(contents) && contents.length) { for (const item of contents) await handleAIItem(item); }
      else { const ans = data.output?.[0]?.content?.[0]?.text || '–û—à–∏–±–∫–∞: –Ω–µ—Ç –æ—Ç–≤–µ—Ç–∞'; appendMessage(ans, 'ai', true); }
    } catch (e) { removeTyping(); appendMessage('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–∞', 'ai', true); console.error(e); }
  };
  reader.readAsDataURL(file);
};

/* Generate image via API (we assume proxy supports a generation model and returns a URL in content.url) */
genImageBtn.onclick = async () => {
  const prompt = imagePrompt.value.trim();
  if (!prompt) return alert('–í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');
  appendMessage(`–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${prompt}`, 'user', true);
  showTyping();
  try {
    // request generation - this depends on your proxy; we ask it to use an image model and return url
    const body = JSON.stringify({ model: 'gpt-image-1', prompt });
    const res = await fetchWithTimeout(API_URL, { method: 'POST', headers: {'Content-Type':'application/json'}, body }, 120000);
    const data = await res.json();
    removeTyping();
    // expect data.output[0].content to contain item with type:'image' and url
    const contents = data.output?.[0]?.content || [];
    if (Array.isArray(contents) && contents.length) {
      for (const item of contents) await handleAIItem(item);
    } else if (data.data && data.data[0] && (data.data[0].url || data.data[0].b64_json)) {
      // fallback: legacy format
      if (data.data[0].url) appendMessage(data.data[0].url, 'ai', true, 'image');
      else if (data.data[0].b64_json) {
        const blobUrl = base64ToBlobUrl(data.data[0].b64_json, 'image/png');
        appendMessage(blobUrl, 'ai', true, 'image', 'gen.png');
      }
    } else {
      appendMessage('–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è ‚Äî –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞', 'ai', true);
    }
  } catch (e) { removeTyping(); appendMessage('–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è', 'ai', true); console.error(e); }
};

/* Buttons wiring */
sendBtn.onclick = () => sendMessage();
inputText.addEventListener('keydown', e => { if (e.key === 'Enter') sendMessage(); });
clearBtn.onclick = () => { chatEl.innerHTML = ''; saveChatToStorage(); };

/* TTS toggle */
ttsToggle.onclick = () => { ttsEnabled = !ttsEnabled; ttsToggle.textContent = ttsEnabled ? '–í–∫–ª—é—á–µ–Ω–æ üîä' : '–û—Ç–∫–ª—é—á–µ–Ω–æ üîà'; };

/* Download chat to TXT */
downloadBtn.onclick = () => {
  const rows = [...chatEl.querySelectorAll('.msg')].map(m => {
    const who = m.classList.contains('user') ? '–í—ã' : '–ò–ò';
    const b = m.querySelector('.bubble');
    const type = b?.dataset?.type || 'text';
    if (type === 'text') return `${who}: ${b.dataset.raw || b.textContent}`;
    if (type === 'image') return `${who}: [–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ] ${b.dataset.filename || b.dataset.raw || ''}`;
    if (type === 'file') return `${who}: [–§–∞–π–ª] ${b.dataset.filename || b.dataset.raw || ''}`;
    return `${who}: ${b.dataset.raw || b.textContent}`;
  }).join('
');
  const blob = new Blob([rows], { type: 'text/plain;charset=utf-8' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'dialog.txt';
  a.click();
  URL.revokeObjectURL(a.href);
};

/* Autosave checkbox */
autosaveCheckbox.addEventListener('change', () => { if (autosaveCheckbox.checked) saveChatToStorage(); });

/* Clear storage */
clearStorageBtn.addEventListener('click', () => { if (confirm('–û—á–∏—Å—Ç–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—É—é –∏—Å—Ç–æ—Ä–∏—é?')) clearStorageAndUI(); });

/* Load saved chat on start */
window.addEventListener('load', () => { autosaveCheckbox.checked = true; loadChatFromStorage(); });

/* double-click AI bubble to speak or download file */
chatEl.addEventListener('dblclick', (e) => {
  const b = e.target.closest('.bubble');
  if (!b) return;
  const parent = b.closest('.msg');
  if (parent && parent.classList.contains('ai')) {
    if ((b.dataset.type || 'text') === 'text') speakText(b.textContent || '');
    if ((b.dataset.type || '') === 'file') { const a = b.querySelector('a'); if (a) a.click(); }
  }
});
</script>
</body>
</html>
